package test;

import java.io.InputStream;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Test;

import com.ibm.integration.test.v1.NodeSpy;
import com.ibm.integration.test.v1.NodeStub;
import com.ibm.integration.test.v1.SpyObjectReference;
import com.ibm.integration.test.v1.TestMessageAssembly;
import com.ibm.integration.test.v1.TestSetup;
import com.ibm.integration.test.v1.exception.TestException;

import static com.ibm.integration.test.v1.Matchers.*;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.fail;

public class Sample_ace_application_sample_message_flow_get_id_from_update_message_0002_Test {

	/*
	 * Sample_ace_application_sample_message_flow_get_id_from_update_message_0002_Test
	 * Test generated by IBM App Connect Enterprise Toolkit 12.0.6.0 on Oct 26, 2022 8:41:15 AM
	 */

	@AfterEach
	public void cleanupTest() throws TestException {
		// Ensure any mocks created by a test are cleared after the test runs 
		TestSetup.restoreAllMocks();
	}

	@Test
	public void sample_ace_application_sample_message_flow_get_id_from_update_message_TestCase_001()
			throws TestException {

		// Define the SpyObjectReference for the node we're going to mock
		SpyObjectReference nodeToBeMockedRef = new SpyObjectReference().application("sample-ace-application").messageFlow("sample_message_flow")
				.node("retrieve current todo details");   

		// Define the SpyObjectReference objects for the start and end of our test run
		SpyObjectReference kafkaInputObjRef = new SpyObjectReference().application("sample-ace-application").messageFlow("sample_message_flow")
		        .node("Kafka consumer todo updates");  
		SpyObjectReference postgresObjRef = new SpyObjectReference().application("sample-ace-application").messageFlow("sample_message_flow")
				.node("insert into database");  

		// Initialise NodeSpy objects
		NodeSpy kafkaInputSpy = new NodeSpy(kafkaInputObjRef);
		NodeSpy postgresSpy = new NodeSpy(postgresObjRef);
		
		
		// Initialize the service stub to avoid needing an HTTP server for unit testing
		NodeStub serviceStub = new NodeStub(nodeToBeMockedRef);
		
		// Create a Message Assembly and load it with the HTTP result
		TestMessageAssembly serviceResultMessageAssembly = new TestMessageAssembly();
		// Directly create the JSON data; useful for small testcases. We could also record the message and use that instead.
		serviceResultMessageAssembly.buildJSONMessage("{\"userId\": 1, \"id\": 1, \"title\": \"delectus aut autem\", \"completed\": false}");

        // Program the stub to return this dummy result instead of calling the service
		serviceStub.onCall().propagatesMessage("in", "out", serviceResultMessageAssembly);

		// Configure the "in" terminal on the Loopback Request node not to propagate.
		// If we don't do this, then the node will throw exceptions when it realizes
		// we haven't actually configured it properly.
		postgresSpy.setStopAtInputTerminal("in");

		// Directly create the JSON data; useful for small testcases.
		TestMessageAssembly inputMessageAssembly = new TestMessageAssembly();
        inputMessageAssembly.messagePath("JSON.Data.id").setValue(1);
        inputMessageAssembly.messagePath("JSON.Data.message").setValue("quick test");
        
		// Now call propagate on the "out" terminal of the Kafka Input node.
		// This takes the place of an actual Kafka message: we simple hand the node
		// the message assembly and tell it to propagate that as if it came from an
		// actual client. This line is where the flow is actually run.
		kafkaInputSpy.propagate(inputMessageAssembly, "out");
		
		// Validate the results from the flow execution
        // We will now pick up the message that is propagated into the Loopback Request node and validate it
		TestMessageAssembly loopbackMessageAssembly = postgresSpy.receivedMessageAssembly("in", 1);
		
		// Should still have the title
		assertEquals("delectus aut autem", loopbackMessageAssembly.messagePath("JSON.Data.title").getStringValue());
		// and also have the encoded title
		assertEquals("RU5DT0RFRDogZGVsZWN0dXMgYXV0IGF1dGVt", loopbackMessageAssembly.messagePath("JSON.Data.encodedTitle").getStringValue());
	}

}
